/**
 * API Client
 * 
 * This file is a stub for the future autogenerated API client.
 * When the backend is implemented, this file will be replaced
 * by an autogenerated client using OpenAPI/Swagger codegen or similar.
 * 
 * For now, it provides typed interfaces and placeholder implementations.
 */

import apiClient from './api-client';
import { TextBlock } from '../store/models';

// Types (these will be autogenerated from OpenAPI spec)
export interface ProcessPageRequest {
  pageId: string;
  imagePath: string;
}

export interface ProcessPageResponse {
  pageId: string;
  textBlocks: TextBlock[];
  processingTime: number;
}

export interface MangaMetadata {
  id: string;
  title: string;
  author?: string;
  tags?: string[];
}

// API Methods (these will be autogenerated)

/**
 * Get text blocks for a specific page
 */
export async function getPageTextBlocks(pageId: string): Promise<TextBlock[]> {
  try {
    const response = await apiClient.get<TextBlock[]>(`/pages/${pageId}/text-blocks`);
    return response.data;
  } catch (error) {
    console.error('Error fetching page text blocks:', error);
    // Return empty array for now since backend is not implemented
    return [];
  }
}

/**
 * Process a manga page with OCR
 */
export async function processMangaPage(pageId: string, imagePath: string): Promise<ProcessPageResponse> {
  try {
    const response = await apiClient.post<ProcessPageResponse>('/pages/process', {
      pageId,
      imagePath,
    });
    return response.data;
  } catch (error) {
    console.error('Error processing manga page:', error);
    // Return mock data for now since backend is not implemented
    return {
      pageId,
      textBlocks: [],
      processingTime: 0,
    };
  }
}

/**
 * Get manga metadata
 */
export async function getMangaMetadata(mangaId: string): Promise<MangaMetadata | null> {
  try {
    const response = await apiClient.get<MangaMetadata>(`/manga/${mangaId}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching manga metadata:', error);
    return null;
  }
}

/**
 * Update manga metadata
 */
export async function updateMangaMetadata(
  mangaId: string,
  metadata: Partial<MangaMetadata>
): Promise<MangaMetadata> {
  const response = await apiClient.patch<MangaMetadata>(`/manga/${mangaId}`, metadata);
  return response.data;
}

/**
 * Health check
 */
export async function healthCheck(): Promise<{ status: string; version: string }> {
  try {
    const response = await apiClient.get<{ status: string; version: string }>('/health');
    return response.data;
  } catch (error) {
    return { status: 'unavailable', version: 'unknown' };
  }
}

